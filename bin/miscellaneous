#!/usr/bin/env bash
#
# Author:
#   Miscellaneous 
#
# Description:
#   Various helper functions
#
# Dependencies:
#   None
#
# Configuration:
#   See each function for configuration & usage

# Header logging
_header() {
	printf "\n%s%s:%s\n" "$(tput setaf 7)" "$@" "$(tput sgr0)"
}

# Success logging
_success() {
	printf "%s✓ Success: \t%s%s\n" "$(tput setaf 2)" "$(tput sgr0)" "$@"
}

# Info logging
_info() {
	printf "%sⓘ  Info: \t%s%s\n" "$(tput setaf 4)" "$(tput sgr0)" "$@"
}

# Error logging
_error() {
	printf "%s⊘ Error: \t%s%s. Aborting\n" "$(tput setaf 1)" "$(tput sgr0)" "$@"
	exit 1
}

# Warning logging
_warning() {
	printf "%s⚠ Warning: \t%s%s\n" "$(tput bold ; tput setaf 3)" "$(tput sgr0)" "$@"
}

# Question logging
_question() {
	printf "\n%s==> %s?%s\n" "$(tput setaf 3)" "$@" "$(tput sgr0)"
}

# Command/Processing logging
_process() {
	printf "%s┃ Processing: \t%s%s\n" "$(tput setaf 6)" "$(tput sgr0)" "$@"
}

# Ask for confirmation before proceeding
seek_confirmation() {
	printf "\n%s==> %s?%s\n" "$(tput setaf 3)" "$@" "$(tput sgr0)"
	read -p "Continue? (y/n) " -n 1
	printf "\n"
}

# Test whether the result of an 'ask' is a confirmation
is_confirmed() {
	if [[ "$REPLY" =~ ^[Yy]$ ]]; then
		return 0
	fi
	return 1
}

# Create a new directory and enter it
function md() {
  mkdir -p "$@" && cd "$@"
}


# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile="${@%/}.tar"
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
	)

	local cmd=""
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli"
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi

	_process "Compressing .tar using \`${cmd}\`"
	"${cmd}" -v "${tmpFile}" || return 1
	[ -f "${tmpFile}" ] && rm "${tmpFile}"
	[[ $? ]] && _success "${tmpFile}.gz created successfully"
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
	if [ -t 0 ]; then # argument
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	else # pipe
		python -mjson.tool | pygmentize -l javascript
	fi
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified."
		return 1
	fi

	local domain="${1}"
	echo "Testing ${domain}…"
	echo # newline

	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" 2>&1);

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_header, no_serial, no_version, \
			no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux");
			echo "Common Name:"
			echo # newline
			echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//";
			echo # newline
			echo "Subject Alternative Name(s):"
			echo # newline
			echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
				| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
			return 0
	else
		echo "ERROR: Certificate not found.";
		return 1
	fi
}

# Manually remove a downloaded app or file from the quarantine
function unquarantine() {
	for attribute in com.apple.metadata:kMDItemDownloadedDate com.apple.metadata:kMDItemWhereFroms com.apple.quarantine; do
		xattr -r -d "$attribute" "$@"
	done
}

# Install Grunt plugins and add them as `devDependencies` to `package.json`
# Usage: `gi contrib-watch contrib-uglify zopfli`
function gi() {
	local IFS=,
	eval npm install --save-dev grunt-{"$*"}
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
function v() {
	if [ $# -eq 0 ]; then
		vim .
	else
		vim "$@"
	fi
}

# `o` with no arguments opens current directory, otherwise opens the given
# location
function o() {
	if [ $# -eq 0 ]; then
		open .
	else
		open "$@"
	fi
}

# `np` with an optional argument `patch`/`minor`/`major`/`<version>`
# defaults to `patch`
function np() {
	git pull --rebase && \
	rm -rf node_modules && \
	npm install && \
	npm test && \
	npm version ${1:=patch} && \
	npm publish && \
	git push origin master && \
	git push origin master --tags
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

mount_installers() {
	# @TODO: add way to automate moving dropbox files and then running this
	security find-generic-password -wD "disk image password" -l "$1" | hdiutil attach -stdinpass ${HOME}/.bash/pkg/$1
}

are_you_root() {
	# @TODO: verify this even works, maybe be overkill
	# User should be root
	if [ "$(whoami)" != "root" ]; then
		printf "$(tput setaf 1)⊘ Error: $(tput sgr0)%s!\n" "User must have admin privileges in order to install. Aborting"
		return 1
	fi
	return 0
}

capitalize() {
	echo "$(tr '[:lower:]' '[:upper:]' <<< ${1:0:1})${1:1}"
}

print_version() {
	local line=$1
	shift
	local word=$1
	shift

	# set local variable to excecuted arguments that is passed in
	echo "$( $@ | head -$line | tail -1 | cut -d ' ' -f $word )"
}


# Test whether we're in a git repo
is_git_repo() {
	$(git rev-parse --is-inside-work-tree &> /dev/null)
}

# Convert file with line items into single string
file_to_string() {
	# set a local array variable
	local -a tmp_string
	# store IFS within a temp variable
	OIFS=$IFS
	# set the separator to a carriage return & a new line break
	# read in passed-in file and store as an array
	IFS=$'\r\n' files=($(cat $1))
	# loop through array
	for index in ${files[*]}
	do
		# create a string of all files with a comma at the end
		tmp=$( printf "%s, " "${files[@]}" )
	done
	# reset IFS back
	IFS=$OIFS
	# print out result with last character removed
	echo "${tmp%%??}\n"
}
